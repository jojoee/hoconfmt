---
description: hoconfmt project context and conventions
globs:
alwaysApply: true
---

# hoconfmt Project

An opinionated HOCON formatter with zero configuration. See [README.md](../README.md) for full documentation (API, formatting rules, usage examples).

## Project Structure

```
hoconfmt/
├── src/
│   ├── types.ts      # TypeScript interfaces
│   ├── lexer.ts      # Tokenizer
│   ├── parser.ts     # AST builder
│   ├── formatter.ts  # Formatting logic
│   ├── index.ts      # Public API (check, format)
│   └── cli.ts        # CLI interface
├── test/             # Vitest tests (*.test.ts)
├── resource/         # Test HOCON files
├── bin/              # CLI binary
└── dist/             # Build output (ESM, CJS, UMD)
```

## Technology Stack

- TypeScript (ES2022, strict mode)
- Vitest for testing
- esbuild for bundling
- semantic-release for versioning

## TypeScript Conventions

- Use `node:` prefix for built-in imports: `import { readFileSync } from 'node:fs'`
- Use `.js` extension in relative imports: `import { parse } from './parser.js'`
- Interface names use descriptive suffixes: CliOptions, FormatterOptions
- Function names follow verb + noun pattern: parseArgs, checkFile, formatFile

## Testing Conventions

- Test files: `test/*.test.ts`
- Use Vitest with describe/it pattern
- Import from `'vitest'`: `import { describe, it, expect } from 'vitest'`

## Documentation

- Use JSDoc for public API functions with @param, @returns, @example blocks
- Example code blocks in JSDoc should be TypeScript

## CLI Conventions

- Use full form options only (--check, --write, --version, --help)
- No short form aliases (-c, -w, -v, -h)
