---
description: hoconfmt project context and conventions
globs:
alwaysApply: true
---

# hoconfmt Project

An opinionated HOCON formatter with zero configuration. See [README.md](../README.md) for full documentation (API, formatting rules, usage examples).

## Project Structure

```
hoconfmt/
├── src/
│   ├── types.ts      # TypeScript interfaces
│   ├── lexer.ts      # Tokenizer
│   ├── parser.ts     # AST builder
│   ├── formatter.ts  # Formatting logic
│   ├── index.ts      # Public API (check, format)
│   └── cli.ts        # CLI interface
├── test/             # Vitest tests (*.test.ts)
├── resource/         # Test HOCON files
├── bin/              # CLI binary
└── dist/             # Build output (ESM, CJS, UMD)
```

## Technology Stack

- TypeScript (ES2022, strict mode)
- Node.js >= 18.0.0 (pinned in package.json engines and CI/CD)
- Vitest for testing (with 80% coverage threshold)
- esbuild for bundling (ESM, CJS, UMD formats)
- semantic-release for versioning
- ts-standard for linting (no separate ESLint/Prettier)
- Docker support (Dockerfile, GitHub Container Registry)

## TypeScript Conventions

- Use `node:` prefix for built-in imports: `import { readFileSync } from 'node:fs'`
- Use `.js` extension in relative imports: `import { parse } from './parser.js'`
- Interface names use descriptive suffixes: CliOptions, FormatterOptions, *Node
- Function names follow verb + noun pattern: parseArgs, checkFile, formatFile
- Enum names use PascalCase: TokenType
- All interfaces extend BaseNode for AST nodes
- Use `type` for unions: `type ValueNode = StringNode | NumberNode | ...`
- Strict TypeScript config with noUncheckedIndexedAccess, noUnusedLocals, noImplicitReturns

## Testing Conventions

- Test files: `test/*.test.ts`
- Use Vitest with describe/it pattern
- Import from `'vitest'`: `import { describe, it, expect } from 'vitest'`

## Documentation

- Use JSDoc for public API functions with @param, @returns, @example blocks
- Example code blocks in JSDoc should be TypeScript

## CLI Conventions

- Use full form options only (--check, --write, --version, --help)
- No short form aliases (-c, -w, -v, -h)
- Exit code 0 for success, 1 for failure
- Provide clear error messages with suggestions
- Show progress indicators (✓ for success, ✗ for errors)
- Include file counts and summary after processing

## Verification Steps

Before committing changes, run these verification steps:

1. **Linting**: `npm run lint` - Check code quality (warnings for console in CLI are expected)
2. **Unit Tests**: `npm run test` - Verify all tests pass
3. **Code Coverage**: `npm run test:coverage` - Check coverage metrics
4. **Build**: `npm run build && npm run build:cli` - Ensure all formats build successfully

## Verification Steps (File Pattern Matching)

Verify glob pattern support works correctly:

```bash
# --check tests
./bin/hoconfmt.js --check resource/01-simple-key-value.conf  # Single file
./bin/hoconfmt.js --check resource/                          # Directory
./bin/hoconfmt.js --check "resource/**/*.conf"               # Glob with **
./bin/hoconfmt.js --check "resource/*.conf"                  # Glob with wildcard
./bin/hoconfmt.js --check "nonexistent/**/*.conf"            # Non-matching (error expected)

# --write tests
./bin/hoconfmt.js --write resourceout/01-simple-key-value.conf  # Single file
./bin/hoconfmt.js --write resourceout/                          # Directory
./bin/hoconfmt.js --write "resourceout/**/*.conf"               # Glob with **
./bin/hoconfmt.js --write "resourceout/*.conf"                  # Glob with wildcard

# Extension filter test
cp resource/01-simple-key-value.conf resource/01-simple-key-value.notconf
./bin/hoconfmt.js --check "resource/01-simple-key-value.*"   # Should process 1 .conf file only
rm resource/01-simple-key-value.notconf
```

## Code Architecture

- Lexer-Parser-Formatter pipeline: `lexer.ts` → `parser.ts` → `formatter.ts`
- Formatter implemented as class with private methods
- Single responsibility: each module handles one concern
- AST-based formatting (not string manipulation)
- Options pattern with DEFAULT_OPTIONS (zero-config philosophy)

## Error Handling

- Use try-catch blocks with graceful degradation
- Return result objects: `{ ok: boolean, error?: string }`
- Never throw errors from public API
- Provide meaningful error messages

## Resource Files

- Test examples in `resource/*.conf` (numbered: 01-*, 02-*, etc.)
- Expected formatted output in `resourceout/*.conf` (matches resource/ structure)
- Use real-world HOCON patterns for testing

To regenerate expected output files:

```bash
cp -r resource/* resourceout/ && npm install && npm run build:cli && ./bin/hoconfmt.js --write resourceout/
```

This command copies all resource files, builds the CLI, and formats them in place to create expected output.

## Post-Work

After implementing a feature:

1. **Update README.md** - Document new formatting rules or API changes
2. **Update resource files**:
   - Add examples to `resource/all-cases.conf` (INVALID and VALID sections)
   - Create case file in `resource/cases/` folder (e.g., `16-blank-lines.conf`)
3. **Git commit** - Use semantic-release pattern (feat:, fix:, docs:, etc.)
